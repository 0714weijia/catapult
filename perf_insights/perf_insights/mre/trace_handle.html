<!DOCTYPE html>
<!--
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/guid.html">
<link rel="import" href="/tracing/base/xhr.html">
<link rel="import" href="/tracing/base/utils.html">
<link rel="import" href="/tracing/extras/full_config.html">
<link rel="import" href="/tracing/importer/import.html">
<link rel="import" href="/tracing/model/model.html">

<script>
'use strict';

tr.exportTo('pi.mre', function() {
  function TraceHandle(sourceURL) {
    this.sourceURL_ = sourceURL;
  }

  TraceHandle.prototype = {
    get sourceURL() { return this.sourceURL_; },

    asDict: function() {
      var d = {
        source_url: this.source_url_
      };

      this._asDictInto(d);
      if (d.type === undefined)
        throw new Error('_asDictInto must set type field');
    },

    read: function() {
      throw new Error('Not implemented');
    }
  };

  TraceHandle.fromDict = function(handleDict) {
    if (handleDict.type === 'local_file')
      return FileURLTraceHandle.fromDict(handleDict);

    throw new Error('Not implemented: fromDict for ' + handleDict.type);
  };


  function FileURLTraceHandle(sourceURL, metadata) {
    // TODO(eakuefner): assert startswith file://
    TraceHandle.call(this, sourceURL);
    this.metadata = metadata;
  }

  FileURLTraceHandle.prototype = {
    __proto__: TraceHandle.prototype,

    _asDictInto: function(handleDict) {
      handleDict.metadata = this.metadata;
      handleDict.type = 'local_file';
    },

    read: function() {
      try {
        var traceData = tr.b.getSync(this.sourceURL);
      } catch (ex) {
        var err = new Error('Could not open ' + this.sourceURL);
        err.name = 'TraceImportError';
        throw err;
      }

      // Load the model.
      var model = new tr.Model();
      try {
        var importOptions = new tr.importer.ImportOptions();
        importOptions.pruneEmptyContainers = false;
        importOptions.showImportWarnings = false;

        var i = new tr.importer.Import(model, importOptions);
        i.importTraces([traceData]);
      } catch (ex) {
        ex.name = 'TraceImportError';
        throw ex;
      }

      model.sourceURLThatCreatedThisTrace = this.sourceURL_;

      // Mixin the metadata in case it's interesting to the mapper.
      var metadata = opt_metadata || {};
      for (var k in metadata) {
        if (model.metadata[k] !== undefined) {
          var err = new Error(k + ' is on model and corpus tables!');
          err.name = 'TraceImportError';
          throw err;
        }
        model.metadata[k] = metadata[k];
      }

      return model;
    }
  };

  FileURLTraceHandle.fromDict = function(handleDict) {
    return new FileURLTraceHandle(handleDict.source_url, handleDict.metadata);
  }

  return {
    TraceHandle: TraceHandle,
    FileURLTraceHandle: FileURLTraceHandle
  };
});
</script>
