<!DOCTYPE html>
<!--
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/units/units.html">
<link rel="import" href="/tracing/base/units/histogram.html">
<link rel="import" href="/perf_insights/mre/function_handle.html">
<link rel="import" href="/perf_insights/mappers/slice_cost.html">
<link rel="import" href="/perf_insights/mappers/thread_grouping.html">
<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/extras/chrome/chrome_model_helper.html">
<link rel="import" href="/tracing/extras/rail/rail_interaction_record.html">
<link rel="import" href="/tracing/extras/rail/rail_score.html">
<link rel="import" href="/tracing/model/ir_coverage.html">

<script>
'use strict';


tr.exportTo('pi.m', function() {
  function v8ReportMapFunction(results, model) {
    var allIRs = [];
    var irDurations = {};
    model.interactionRecords.forEach(function(ir) {
      if (!(ir instanceof tr.e.rail.RAILInteractionRecord))
        return;
      allIRs.push(ir);
      var railName = tr.e.rail.userFriendlyRailTypeName(ir.railTypeName);

      if (irDurations[railName] === undefined)
        irDurations[railName] = 0;

      irDurations[railName] += ir.rawCpuMs;
    });
    var railTypeNameByGUID = getRAILTypeNameForEventsByGUID(model, allIRs);

    var threadGrouping = new pi.m.ThreadGrouping();
    threadGrouping.autoInitUsingHelpers(model);

    var sliceCosts = pi.m.getSliceCostReport(model, threadGrouping,
                                             railTypeNameByGUID,
        function(event) {
          return event.title.startsWith('V8.');
        },
        function(event) {
          function _get_parent_data(event) {
            var curSlice = event;
            var data = {};
            data['name'] = "Unknown";
            data['js'] = "Unknown";
            while (curSlice.parentSlice) {
              curSlice = curSlice.parentSlice;
              if (curSlice.title === 'v8.run') {
                data['name'] = curSlice.title;
                data['js'] = curSlice.args['fileName'];
              } else if (curSlice.title === 'v8.compile') {
                data['name'] = curSlice.title;
                data['js'] = curSlice.args['fileName'];
              } else if (curSlice.title === 'v8.callModuleMethod') {
                data['name'] = curSlice.title;
                data['js'] = "Unknown";
              } else if (curSlice.title === 'FunctionCall') {
                data['name'] = curSlice.title;
                data['js'] = "Unknown";
              }
            }
            return data;
          }
          function _guess_framework_from_js_file(js_file) {
            var frameworks = {
              "jquery": ["jquery"],
              "google search": ["google.com/search?", "www.google."],
              "google adsense": ["pagead2.googlesyndication.com/pagead/"],
              "modernizr": ["modernizr"],
              "google analytics": ["google-analytics.com"],
              "easeljs": ["easeljs"],
              "google+": ["apis.google.com/js/client:plusone.js"],
              "facebook": ["connect.facebook.net"],
              "yandex": ["yandex.ru/metrika/"],
              "doubleclick": [".doubleclick"],
              "baidu": ["baidu.com/?"],
              "twitter": ["twitter.com/?"]
            };

            for (var k in frameworks) {
              var keywords = frameworks[k];
              for (var i = 0; i < keywords.length; i++) {
                if (js_file.indexOf(keywords[i]) > -1) {
                  return k;
                }
              }
            }
            return "Unknown/Uncategorized";
          }
          function _cleanup_framework_name(name) {
            var js_name = name;
            if (js_name === '') {
              js_name = 'Unknown';
            }
            if (js_name.length > 150) {
              js_name = js_name.substring(0, 150) + '...';
            }
            return js_name;
          }
          var data = _get_parent_data(event);
          data['framework'] = _guess_framework_from_js_file(data['js']);
          data['js_clean'] = _cleanup_framework_name(data['js']);
          return data;
        }
    );

    var wr = {
      irDurations: irDurations,
      sliceCosts: sliceCosts,
      sourceURL: model.sourceURLThatCreatedThisTrace
    };

    results.addResult('wr', wr);
  }

  function getRAILTypeNameForEventsByGUID(model, railIRs) {
    var railTypeNameByGUID = {};
    railIRs.forEach(function applyAssociatedToRTN(ir) {
      ir.associatedEvents.forEach(function applyEventToRTN(event) {
        // Unassociated events have already been assigned to a RTN.
        if (railTypeNameByGUID[event.guid] !== undefined)
          return;
        railTypeNameByGUID[event.guid] = tr.e.rail.userFriendlyRailTypeName(
            ir.railTypeName);
      }, this);
    }, this);

    model.iterateAllEvents(function storeEventToUnassociatedSet(event) {
      if (railTypeNameByGUID[event.guid] !== undefined)
        return;
      railTypeNameByGUID[event.guid] = 'Unknown';
    });
    return railTypeNameByGUID;
  }

  pi.mre.FunctionRegistry.register(v8ReportMapFunction);

  // Exporting for tests.
  return {
    v8ReportMapFunction: v8ReportMapFunction
  };
});

</script>
