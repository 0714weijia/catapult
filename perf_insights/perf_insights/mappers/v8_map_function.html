<!DOCTYPE html>
<!--
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/units/units.html">
<link rel="import" href="/tracing/base/units/histogram.html">
<link rel="import" href="/perf_insights/mre/function_handle.html">
<link rel="import" href="/perf_insights/mappers/slice_cost.html">
<link rel="import" href="/perf_insights/mappers/thread_grouping.html">
<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/extras/chrome/chrome_model_helper.html">
<link rel="import" href="/tracing/extras/rail/rail_interaction_record.html">
<link rel="import" href="/tracing/extras/rail/rail_score.html">
<link rel="import" href="/tracing/model/ir_coverage.html">

<script>
'use strict';


tr.exportTo('pi.m', function() {
  function v8ReportMapFunction(results, model) {
    var allIRs = [];
    model.interactionRecords.forEach(function(ir) {
      if (!(ir instanceof tr.e.rail.RAILInteractionRecord))
        return;
      allIRs.push(ir);
      var railName = tr.e.rail.userFriendlyRailTypeName(ir.railTypeName);
    });

    var railTypeNameByGUID = getRAILTypeNameForEventsByGUID(model, allIRs);

    var threadGrouping = new pi.m.ThreadGrouping();
    threadGrouping.autoInitUsingHelpers(model);
    var last_known_framework = ["Unknown/Uncategorized"];

    var sliceCosts = [];

    model.iterateAllEvents(function(event) {
      if (!(event instanceof tr.model.ThreadSlice))
        return;

      if (!event.title.startsWith('V8.'))
        return;

        function _get_parent_data(event) {
          var curSlice = event;

          var data = {};
          data['js'] = "Unknown";
          while (curSlice) {
            if (curSlice.title === 'v8.run') {
              data['js'] = curSlice.args['fileName'];
            } else if (curSlice.title === 'v8.compile') {
              data['js'] = curSlice.args['fileName'];
            } else if (curSlice.title === 'v8.callModuleMethod') {
              data['js'] = "Unknown";
            } else if (curSlice.title === 'FunctionCall') {
              //console.log('Data: ' + curSlice.args.data.scriptName + ', old: ' + data['js']);
                var scriptName = curSlice.args['data']['scriptName'];
                if (scriptName.indexOf('http') != -1) {
                  data['js'] = scriptName;
                }
            }
            curSlice = curSlice.parentSlice;
          }
          return data;
        }

        function _guess_framework_from_js_file(js_file) {
          var frameworks = {
            // Some commone js libs.
              "jquery": ["jquery"],
              "angular": ["angular"],
              "underscore": ["underscore"],
              "respond.js": ["respond.js"],
              "easeljs": ["easeljs"],
              "modernizr": ["modernizr"],
              "cloudflare": ["cloudflare.min.js"],
              "greensock": ["gsap/"],
              "mootools": ["mootools"],
              "zepto": ["zepto."],
              "webfont": ["webfont.js"],
              "closure": ["closure/"],
              "ektron": ["ektron"],
              "swfobject": ["swfobject"],
              "html5shiv": ["html5shiv"],
              "requirejs": ["require.js"],

              // Just dividing these out into common sites.
              "google search": ["google.com/search?", "www.google."],
              "google adsense": ["pagead2.googlesyndication.com/pagead/"],
              "google analytics": ["google-analytics.com"],
              "adobe": ["adobe."],
              "facebook": ["facebook.", "fbcdn."],
              "outlook": ["outlook.", ".live."],
              "craigslist": ["craigslist."],
              "amazon": ["amazon."],
              "yandex": ["yandex."],
              "scene7": ["s7sdk/"],
              "doubleclick": [
                  ".doubleclick", "gpt.js", "gtm.js", ".googletagservices."],
              "baidu": ["baidu."],
              "bing": ["bing."],
              "twitter": ["twitter."],
              "wish": ["MobileWebsiteCore"],
              "misc google": ["google.", "googleapis."],
              "misc extensions": ["chrome-extension://", "chrome://"]
          };

          for (var k in frameworks) {
            var keywords = frameworks[k];
            for (var i = 0; i < keywords.length; i++) {
              if (js_file.indexOf(keywords[i]) > -1) {
                //last_known_framework[0] = k;
                return k;
              }
            }
          }

          // TODO: This is terrible, find a better way to attribute the
          // unknown callers to a framework. Ideally we'd actually have
          // access to data about the script or method that's running.
          return last_known_framework[0];
        }

        function _cleanup_framework_name(name) {
          var js_name = name;
          if (js_name === '') {
            js_name = 'Unknown';
          }
          if (js_name.length > 120) {
            js_name = js_name.substring(0, 120) + '...';
          }
          return js_name;
        }

        var ufc = model.getUserFriendlyCategoryFromEvent(event);

        var data = _get_parent_data(event);
        data.framework = _guess_framework_from_js_file(data.js);
        var scriptURLClean = _cleanup_framework_name(data.js);

        //console.log('After: ' + scriptURLClean + ', for slice title: ' + event.title);

        var sliceData = {
          threadGroup: threadGrouping.getGroupNameForEvent(event),
          railTypeName: railTypeNameByGUID[event.guid],
          userFriendlyCategory: ufc || 'other',
          title: tr.e.chrome.SliceTitleFixer.fromEvent(event),
          selfTime: event.selfTime,
          cpuSelfTime: event.cpuSelfTime,
          scriptURL: data.js,
          scriptURLClean: scriptURLClean,
          framework: data.framework,
          traceURL: model.sourceURLThatCreatedThisTrace
        }

        var key = sliceData.threadGroup + '/' +
                  sliceData.railTypeName + '/' +
                  sliceData.framework + '/' +
                  //sliceData.scriptURLClean + '/' +
                  sliceData.title;

        var newElement = {
          key: key,
          value: sliceData
        }
        sliceCosts.push(newElement);
    });

    //console.log(JSON.stringify(sliceCosts, undefined, 2));
    results.addResult('wr', sliceCosts);
  }

  function getRAILTypeNameForEventsByGUID(model, railIRs) {
    var railTypeNameByGUID = {};
    railIRs.forEach(function applyAssociatedToRTN(ir) {
      ir.associatedEvents.forEach(function applyEventToRTN(event) {
        // Unassociated events have already been assigned to a RTN.
        if (railTypeNameByGUID[event.guid] !== undefined)
          return;
        railTypeNameByGUID[event.guid] = tr.e.rail.userFriendlyRailTypeName(
            ir.railTypeName);
      }, this);
    }, this);

    model.iterateAllEvents(function storeEventToUnassociatedSet(event) {
      if (railTypeNameByGUID[event.guid] !== undefined)
        return;
      railTypeNameByGUID[event.guid] = 'Unknown';
    });
    return railTypeNameByGUID;
  }

  pi.mre.FunctionRegistry.register(v8ReportMapFunction);

  // Exporting for tests.
  return {
    v8ReportMapFunction: v8ReportMapFunction
  };
});

</script>
